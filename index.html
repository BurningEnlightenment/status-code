<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>
index
</title>
</head>
<body>

<h1>Reference implementation for proposed SG14 <code>status_code</code> (<code>&lt;system_error2&gt;</code>) in C++ 11</h1>
<p>(C) 2018 Niall Douglas <a href="http://www.nedproductions.biz/">http://www.nedproductions.biz/</a>
Please send feedback to the SG14 study group mailing list at <a href="https://groups.google.com/a/isocpp.org/d/forum/sg14">https://groups.google.com/a/isocpp.org/d/forum/sg14</a>.</p>
<p>Docs: <a href="https://ned14.github.io/status-code/">https://ned14.github.io/status-code/</a>
(reference API docs are at bottom of page) Linux: <a href="https://travis-ci.org/ned14/status-code"><img alt="Build Status" src="https://travis-ci.org/ned14/status-code.svg?branch=master" /></a> Windows: <a href="https://ci.appveyor.com/project/ned14/status-code/branch/master"><img alt="Build status" src="https://ci.appveyor.com/api/projects/status/doyh9rol1gupcwd0/branch/master?svg=true" /></a></p>
<p>Solves the problems for low latency/large code base users with <code>&lt;system_error&gt;</code>
as listed by <a href="https://wg21.link/P0824">WG21 P0824</a>. This proposed <code>&lt;system_error2&gt;</code>
library is EXPERIMENTAL and is subject to change as the committee evolves the design.
To fetch a drop-in standalone single file implementation:</p>
<pre><code>wget https://github.com/ned14/status-code/raw/develop/single-header/system_error2.hpp
</code></pre>

<h2>Features:</h2>
<ul>
<li>Portable to any C++ 11 compiler. These are known to work:<ul>
<li>&gt;= GCC 5 (due to requiring libstdc++ 5 for sufficient C++ 11 type traits)</li>
<li>&gt;= clang 3.3 with a new enough libstdc++ (previous clangs don't implement inheriting constructors)</li>
<li>&gt;= Visual Studio 2015 (previous MSVC's don't implement inheriting constructors)</li>
</ul>
</li>
<li>Aims to cause zero code generated by the compiler most of the time.</li>
<li>Never calls <code>malloc()</code>.</li>
<li>Header-only library friendly.</li>
<li>Type safe yet with type erasure in public interfaces so it can scale
across huge codebases.</li>
<li>Minimum compile time load, making it suitable for use in the global headers of
multi-million line codebases.</li>
</ul>
<h2>Example of use:</h2>
<table width="100%">
<tr>
<th>POSIX</th>
<th>Windows</th>
</tr>
<tr>
<td valign="top">
<pre><code class="c++">using native_handle_type = int;
native_handle_type open_file(const char *path,
  system_error2::system_code &sc) noexcept
{
  sc.clear();  // clears to empty
  native_handle_type h = ::open(path, O_RDONLY);
  if(-1 == h)
  {
    // posix_code type erases into system_code
    sc = system_error2::posix_code(errno);
  }
  return h;
}
</code></pre>
</td>
<td valign="top">
<pre><code class="c++">using native_handle_type = HANDLE;
native_handle_type open_file(const wchar_t *path,
  system_error2::system_code &sc) noexcept
{
  sc.clear();  // clears to empty
  native_handle_type h = CreateFile(path, GENERIC_READ,
    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
    nullptr,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    nullptr
  );
  if(INVALID_HANDLE_VALUE == h)
  {
    // win32_code type erases into system_code
    sc = system_error2::win32_code(GetLastError());
  }
  return h;
}
</code></pre>
</td>
</tr>
<tr>
<th colspan="2">Portable code</th>
</tr>
<tr>
<td colspan="2">
<pre><code class="c++" style="display: inline-block; position: relative; left: 50%; transform: translateX(-50%);">system_error2::system_code sc;  // default constructs to empty
native_handle_type h = open_file(path, sc);
// Is the code a failure?
if(sc.failure())
{
  // Do semantic comparison to test if this was a file not found failure
  // This will match any system-specific error codes meaning a file not found
  if(sc != system_error2::errc::no_such_file_or_directory)
  {
    std::cerr << "FATAL: " << sc.message().c_str() << std::endl;
    std::terminate();
  }
}
</code></pre>
</tr>
</table>

<h2>Problems with <code>&lt;system_error&gt;</code> solved:</h2>
<ol>
<li>
<p>Does not cause <code>#include &lt;string&gt;</code>, and thus including the entire STL allocator and algorithm
machinery, thus preventing use in freestanding C++ as well as substantially
impacting compile times which can be a showstopper for very large C++ projects.
Only includes the following headers:</p>
<ul>
<li><code>&lt;atomic&gt;</code> to reference count localised strings retrieved from the OS.</li>
<li><code>&lt;cassert&gt;</code> to trap when misuse occurs.</li>
<li><code>&lt;cerrno&gt;</code> for the generic POSIX error codes (<code>errno</code>) which is required to define <code>errc</code>.</li>
<li><code>&lt;cstddef&gt;</code> for the definition of <code>size_t</code> and other types.</li>
<li><code>&lt;cstring&gt;</code> for the system call to fetch a localised string and C string functions.</li>
<li><code>&lt;exception&gt;</code> for the basic <code>std::exception</code> type so we can optionally throw STL exceptions.</li>
<li><code>&lt;initializer_list&gt;</code> so we can permit in-place construction.</li>
<li><code>&lt;new&gt;</code> so we can perform placement new.</li>
<li><code>&lt;type_traits&gt;</code> as we need to do some very limited metaprogramming.</li>
<li><code>&lt;utility&gt;</code> if on C++ 17 or later for <code>std::in_place</code>.</li>
</ul>
<p>These may look like a lot, but in fact just including <code>&lt;atomic&gt;</code> on libstdc++ actually
brings in most of the others in any case, and a total of 200Kb (8,000 lines) of text is including by
<code>system_error2.hpp</code> on libstdc++ 7. Compiling a file including <code>status_code.hpp</code> takes
less than 150 ms with clang 3.3 as according to the <code>-ftime-report</code> diagnostic (a completely
empty file takes 5 ms).</p>
</li>
<li>
<p>Unlike <code>std::error_code</code> which was designed before <code>constexpr</code>, this proposed
implementation has all-<code>constexpr</code> construction and destruction with as many operations
as possible being trivial or literal, with only those exact minimum operations which
require runtime code generation being non-trivial (note: requires C++ 14 for a complete
implementation of this).</p>
</li>
<li>
<p>This in turn means that we solve a long standing problem with <code>std::error_category</code>
in that it is not possible to define a safe custom C++ 11 error category in a header
only library where semantic comparisons would randomly break depending on the direction of wind
blowing when the linker ran. This proposed design is 100% safe to use in header only libraries.</p>
</li>
<li>
<p><code>std::error_code</code>'s boolean conversion operator i.e. <code>if(ec) ...</code> has become
unfortunately ambiguous in real world C++ out there. Its correct meaning is
"if <code>ec</code> has a non-zero value". Unfortunately, much code out in the wild uses
it as if "if <code>ec</code> is errored". This is incorrect, though safe most of the time
where <code>ec</code>'s category is well known i.e. non-zero values are always an error.
For unknown categories supplied by third party code however, it is dangerous and leads
to unpleasant, hard-to-debug, surprise.</p>
<p>The <code>status_code</code> proposed here suffers from no such ambiguity. It can be one of
exactly three meanings: (i) success (ii) failure (iii) empty (uninitialised). There
is no boolean conversion operator, so users must write out exactly what they mean
e.g. <code>if(sc.success()) ...</code>, <code>if(sc.failure()) ...</code>, <code>if(sc.empty()) ...</code>.</p>
</li>
<li>
<p>Relatedly, <code>status_code</code> can now represent successful (informational) codes as
well as failure codes. Unlike <code>std::error_code</code> where zero is given special meaning,
we impose no requirements at all on the choice of coding. This permits safe usage of more
complex C status coding such as the NT kernel's <code>NTSTATUS</code>, which is a <code>LONG</code> whereby bits
31 and 30 determine which of four categories the status is (success, informational, warning,
error), or the very commone case where negative numbers mean failure and positive numbers
mean success-with-information.</p>
</li>
<li>
<p>The relationship between <code>std::error_code</code> and <code>std::error_condition</code> is
confusing to many users reading code based on <code>&lt;system_error&gt;</code>, specifically when is
a comparison between codes <em>semantic</em> or <em>literal</em>? <code>status_code</code> makes all
comparisons <em>semantic</em>, <strong>always</strong>. If you want a literal comparison, you can do one
by hand by comparing domains and values directly.</p>
</li>
<li>
<p><code>std::error_code</code> enforced its value to always be an <code>int</code>. This is problematic
for coding systems which might use a <code>long</code> and implement coding namespaces within
the extended number of bits, or for end users wishing to combine a code with a <code>void *</code>
in order to transmit payload or additional context. As a result, <code>status_code</code> is
templated to its domain, and the domain sets its type. A type erased edition of
<code>status_code&lt;D&gt;</code> is available as <code>status_code&lt;void&gt;</code>, this is for obvious reasons
non-copyable, non-movable and non-destructible.</p>
<p>A more useful type erased edition is <code>status_code&lt;erased&lt;T&gt;&gt;</code> 
which is available if <code>D::value_type</code> is trivially copyable, <code>T</code> is an integral
type, and <code>sizeof(T) &gt;= sizeof(D::value_type)</code>. This lets you use
<code>status_code&lt;erased&lt;T&gt;&gt;</code> in all your public interfaces without
restrictions. As a pointer to the original category is retained, and trivially
copyable types may be legally copied by <code>memcpy()</code>, type erased status codes
work exactly as normal, except that publicly it does not advertise its type.</p>
</li>
<li>
<p><code>std::system_category</code> assumes that there is only one "system" error coding,
something mostly true on POSIX, but not elsewhere. This library defines
<code>system_code</code> to a type erased status code sufficiently large enough to carry
any of the system error codings on the current platform. This allows code to
construct the precise error code for the system failure in question, and
return it type erased from the function. Depending on the system call which
failed, a function may therefore return any one of many system code domains.</p>
</li>
<li>
<p>Too much <code>&lt;system_error&gt;</code> code written for POSIX uses <code>std::generic_category</code>
when they really meant <code>std::system_category</code> because the two are interchangeable
on POSIX. Further confusion stems from <code>std::error_condition</code> also sharing the same
coding and type. This causes portability problems. This library's <code>generic_code</code> has
a value type of <code>errc</code> which is a strong enum. This prevents implicit confusion
with <code>posix_code</code>, whose value type is an <code>int</code> same as <code>errno</code> returns. There is
no distinction between codes and conditions in this library, rather we treat
<code>generic_code</code> as something special, because it represents <code>errc</code>. The cleanup
of these ambiguities in <code>&lt;system_error&gt;</code> should result in users writing clearer
code with fewer unintended portability problems.</p>
</li>
</ol>
<h1>Project index</h1>
<ul>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_CONSTEXPR14"><code>SYSTEM_ERROR2_CONSTEXPR14</code></a> &mdash; Defined to be <code>constexpr</code> when on C++ 14 or better compilers. Usually automatic, can be overriden.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE"><code>SYSTEM_ERROR2_NAMESPACE</code></a> &mdash; The system_error2 namespace name.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE_BEGIN"><code>SYSTEM_ERROR2_NAMESPACE_BEGIN</code></a> &mdash; Begins the system_error2 namespace.</p>
</li>
<li>
<p><a href="doc_config.html#standardese-SYSTEM_ERROR2_NAMESPACE_END"><code>SYSTEM_ERROR2_NAMESPACE_END</code></a> &mdash; Ends the system_error2 namespace.</p>
</li>
<li>
<p><a href="doc_system_code.html#standardese-system_code-hpp"><code>SYSTEM_ERROR2_SYSTEM_ERROR_HPP</code></a></p>
</li>
<li>
<h2>Namespace <code>system_error2</code></h2>
<p><span id="standardese-system_error2"></span></p>
<p>Namespace for the library</p>
<ul>
<li>
<p><a href="doc_com_code.html#standardese-system_error2___com_code_domain"><code>_com_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for COM error codes and/or <code>IErrorInfo</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2___generic_code_domain"><code>_generic_code_domain</code></a> &mdash; The implementation of the domain for generic status codes, those mapped by <code>errc</code> (POSIX).</p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2___nt_code_domain"><code>_nt_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for NT error codes, those returned by NT kernel functions.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2___posix_code_domain"><code>_posix_code_domain</code></a> &mdash; The implementation of the domain for POSIX error codes, those returned by <code>errno</code>.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2___win32_code_domain"><code>_win32_code_domain</code></a> &mdash; (Windows only) The implementation of the domain for Win32 error codes, those returned by <code>GetLastError()</code>.</p>
</li>
<li>
<p><a href="doc_com_code.html#standardese-system_error2__com_code"><code>com_code</code></a> &mdash; (Windows only) A COM error code. Note semantic equivalence testing is only implemented for <code>FACILITY_WIN32</code> and <code>FACILITY_NT_BIT</code>.</p>
</li>
<li>
<p><a href="doc_com_code.html#standardese-system_error2__com_code_domain"><code>com_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the COM code domain. Returned by <code>_com_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2"><code>equivalent</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__erased-ErasedType--"><code>erased</code></a> &mdash; A tag for an erased value type for <code>status_code&lt;D&gt;</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__errc"><code>errc</code></a> &mdash; The generic error coding (POSIX)</p>
</li>
<li>
<p><a href="doc_status_code_domain.html#standardese-system_error2__generic_code"><code>generic_code</code></a> &mdash; The generic code is a status code with the generic code domain, which is that of <code>errc</code> (POSIX).</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__generic_code_domain"><code>generic_code_domain</code></a> &mdash; A constexpr source variable for the generic code domain, which is that of <code>errc</code> (POSIX). Returned by <code>_generic_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2"><code>get</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__in_place"><code>in_place</code></a> &mdash; Aliases <code>std::in_place</code> if on C++ 17 or later, else defined locally.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__in_place_t"><code>in_place_t</code></a> &mdash; Aliases <code>std::in_place_t</code> if on C++ 17 or later, else defined locally.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2"><code>make_status_code</code></a></p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2__nt_code"><code>nt_code</code></a> &mdash; (Windows only) A NT error code, those returned by NT kernel functions.</p>
</li>
<li>
<p><a href="doc_nt_code.html#standardese-system_error2__nt_code_domain"><code>nt_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the NT code domain, which is that of NT kernel functions. Returned by <code>_nt_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator!=</code></a> &mdash; True if the status code’s are not semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_iostream_support.html#standardese-system_error2__operator---DomainType---std__ostream--status_code-DomainType-const--"><code>operator&lt;&lt;</code></a> &mdash; Print the status code to a <code>std::ostream &amp;</code>.</p>
</li>
<li>
<p><a href="doc_generic_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator==</code></a> &mdash; True if the status code’s are semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2__posix_code"><code>posix_code</code></a> &mdash; A POSIX error code, those returned by <code>errno</code>.</p>
</li>
<li>
<p><a href="doc_posix_code.html#standardese-system_error2__posix_code_domain"><code>posix_code_domain</code></a> &mdash; A constexpr source variable for the POSIX code domain, which is that of <code>errno</code>. Returned by <code>_posix_code_domain::get()</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__status_code-DomainType-"><code>status_code</code></a> &mdash; The main workhorse of the system_error2 library, can be typed (<code>status_code&lt;DomainType&gt;</code>), erased-immutable (<code>status_code&lt;void&gt;</code>) or erased-mutable (<code>status_code&lt;erased&lt;T&gt;&gt;</code>).</p>
</li>
<li>
<p><a href="doc_status_code_domain.html#standardese-system_error2__status_code_domain"><code>status_code_domain</code></a> &mdash; Abstract base class for a coding domain of a status code.</p>
</li>
<li>
<p><a href="doc_status_error.html#standardese-system_error2__status_error-DomainType-"><code>status_error</code></a> &mdash; Exception type representing a thrown status_code</p>
</li>
<li>
<p><a href="doc_system_code.html#standardese-system_error2__system_code"><code>system_code</code></a> &mdash; An erased-mutable status code suitably large for all the system codes which can be returned on this system.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2__win32_code"><code>win32_code</code></a> &mdash; (Windows only) A Win32 error code, those returned by <code>GetLastError()</code>.</p>
</li>
<li>
<p><a href="doc_win32_code.html#standardese-system_error2__win32_code_domain"><code>win32_code_domain</code></a> &mdash; (Windows only) A constexpr source variable for the win32 code domain, which is that of <code>GetLastError()</code> (Windows). Returned by <code>_win32_code_domain::get()</code>.</p>
</li>
</ul>
</li>
</ul></body>
</html>
