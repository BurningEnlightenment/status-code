<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>
index
</title>
</head>
<body>

<h1>Reference implementation for proposed SG14 <code>status_code</code> in C++ 11</h1>
<p>(C) 2018 Niall Douglas <a href="http://www.nedproductions.biz/">http://www.nedproductions.biz/</a></p>
<p>Docs: <a href="https://ned14.github.io/status-code/">https://ned14.github.io/status-code/</a>
(reference API docs are at bottom of page)</p>
<p>Solves the problems for low latency/large code base users with <code>&lt;system_error&gt;</code>
as listed by <a href="https://wg21.link/P0824">WG21 P0824</a>. This library is EXPERIMENTAL
and is subject to change as the committee evolves the design.</p>
<h2>Features:</h2>
<ul>
<li>Portable to any C++ 11 compiler. These are known to work:<ul>
<li>&gt;= GCC 5 (due to requiring libstdc++ 5 for sufficient C++ 11 type traits)</li>
<li>&gt;= clang 3.3 with a new enough libstdc++ (previous clangs don't implement inheriting constructors)</li>
<li>Visual Studio 2015 is known to work, 2013 ought to but is untested. Earlier
Visual Studio's probably have insufficient C++ 11 type trait support.</li>
</ul>
</li>
<li>Aims to cause zero code generated by the compiler most of the time.</li>
<li>Never calls <code>malloc()</code>.</li>
<li>Header-only library friendly.</li>
<li>Type safe yet with type erasure in public interfaces so it can scale
across huge codebases.</li>
</ul>
<h2>Problems with <code>&lt;system_error&gt;</code> listed by P0824 solved:</h2>
<ol>
<li>
<p>Does not <code>#include &lt;string&gt;</code>, and thus the entire STL allocator and algorithm
machinery, thus preventing use in freestanding C++ as well as substantially
impacting compile times which can be a showstopper for very large C++ projects.
Only includes the following headers:</p>
<ul>
<li><code>&lt;cassert&gt;</code> to trap when misuse occurs.</li>
<li><code>&lt;cerrno&gt;</code> for the generic POSIX error codes (<code>errno</code>) which is required to define <code>errc</code>.</li>
<li><code>&lt;cstddef&gt;</code> for the definition of <code>size_t</code> and other types.</li>
<li><code>&lt;exception&gt;</code> for the basic <code>std::exception</code> type so we can optionally throw STL exceptions.</li>
<li><code>&lt;new&gt;</code> so we can perform placement new.</li>
<li><code>&lt;type_traits&gt;</code> as we need to do some very limited metaprogramming.</li>
</ul>
<p>Compiling a file including <code>status_code.hpp</code> takes less than 150 ms with clang 3.3
as according to the <code>-ftime-report</code> diagnostic (a completely empty file takes 5 ms).</p>
</li>
<li>
<p>Unlike <code>std::error_code</code> which was designed before <code>constexpr</code>, this proposed
implementation has all-<code>constexpr</code> construction and destruction with as many operations
as possible being trivial or literal, with only those exact minimum operations which
require runtime code generation being non-trivial (note: requires C++ 14 for a complete
implementation of this).</p>
</li>
<li>
<p>This in turn means that we solve a long standing problem with <code>std::error_category</code>
in that it is not possible to define a safe custom C++ 11 error category in a header
only library where semantic comparisons would randomly break depending on the direction of wind
blowing when the linker ran. This proposed design is 100% safe to use in header only libraries.</p>
</li>
<li>
<p><code>std::error_code</code>'s boolean conversion operator i.e. <code>if(ec) ...</code> has become
unfortunately ambiguous in real world C++ out there. Its correct meaning is
"if <code>ec</code> has a non-zero value". Unfortunately, much code out in the wild uses
it as if "if <code>ec</code> is errored". This is incorrect, though safe most of the time
where <code>ec</code>'s category is well known i.e. non-zero values are always an error.
For unknown categories supplied by third party code however, it is dangerous and leads
to unpleasant, hard-to-debug, surprise.</p>
<p>The <code>status_code</code> proposed here suffers from no such ambiguity. It can be one of
exactly three meanings: (i) success (ii) failure (iii) empty (uninitialised). There
is no boolean conversion operator, so users must write out exactly what they mean
e.g. <code>if(ec.success()) ...</code>, <code>if(ec.failure()) ...</code>, <code>if(ec.empty()) ...</code>.</p>
</li>
<li>
<p>Relatedly, <code>status_code</code> can now represent successful (informational) codes as
well as failure codes. Unlike <code>std::error_code</code> where zero is given special meaning,
we impose no requirements at all on the choice of coding.</p>
</li>
<li>
<p>The relationship between <code>std::error_code</code> and <code>std::error_condition</code> is
confusing to many users reading code based on <code>&lt;system_error&gt;</code>, specifically when is
a comparison between codes <em>semantic</em> vs <em>literal</em>? <code>status_code</code> makes all
comparisons <em>semantic</em>, <strong>always</strong>. If you want a literal comparison, you can do one
by hand by comparing domains and values directly.</p>
</li>
<li>
<p><code>std::error_code</code> enforced its value to always be an <code>int</code>. This is problematic
for coding systems which might use a <code>long</code> and implement coding namespaces within
the extended number of bits, or for end users wishing to combine a code with a <code>void *</code>
in order to transmit payload or additional context. As a result, <code>status_code</code> is
templated to its domain, and the domain sets its type. A type erased edition of
<code>status_code&lt;D&gt;</code> is available as <code>status_code&lt;void&gt;</code>, this is for obvious reasons
non-copyable, non-movable and non-destructible.</p>
<p>A more useful type erased edition is <code>status_code&lt;erased&lt;T&gt;&gt;</code> 
which is available if <code>D::value_type</code> is trivially copyable, <code>T</code> is an integral
type, and <code>sizeof(T) &gt;= sizeof(D::value_type)</code>. This lets you use
<code>status_code&lt;erased&lt;T&gt;&gt;</code> in all your public interfaces without
restrictions. As a pointer to the original category is retained, and trivially
copyable types may be legally copied by <code>memcpy()</code>, type erased status codes
work exactly as normal, except that publicly it does not advertise its type.</p>
</li>
</ol>
<h1>Project index</h1>
<ul>
<li>
<p><a href="doc_config.html#standardese-STATUS_CODE_CONSTEXPR14"><code>STATUS_CODE_CONSTEXPR14</code></a> &mdash; Defined to be <code>constexpr</code> when on C++ 14 or better compilers. Usually automatic, can be overriden.</p>
</li>
<li>
<h2>Namespace <code>system_error2</code></h2>
<p><span id="standardese-system_error2"></span></p>
<p>Namespace for the library</p>
<ul>
<li>
<p><a href="doc_status_code.html#standardese-system_error2___generic_code_domain"><code>_generic_code_domain</code></a> &mdash; The implementation of the domain for generic status codes, those mapped by <code>errc</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2"><code>equivalent</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__erased-ErasedType--"><code>erased</code></a> &mdash; A tag for an erased value type for <code>status_code&lt;T&gt;</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__errc"><code>errc</code></a> &mdash; The generic error coding (POSIX)</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2"><code>generic_code</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__generic_code_domain"><code>generic_code_domain</code></a> &mdash; A constexpr source variable for the generic code domain</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2"><code>get</code></a></p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator!=</code></a> &mdash; True if the status code’s are not semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__operator---DomainType1-DomainType2--status_code-DomainType1-const--status_code-DomainType2-const--"><code>operator==</code></a> &mdash; True if the status code’s are semantically equal via <code>equivalent()</code>.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__status_code-"><code>status_code</code></a> &mdash; A type erased lightweight status code reflecting empty, success, or failure.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__status_code_domain"><code>status_code_domain</code></a> &mdash; Abstract base class for a domain of a status code.</p>
</li>
<li>
<p><a href="doc_status_code.html#standardese-system_error2__status_error-DomainType-"><code>status_error</code></a> &mdash; Exception type representing a thrown status_code</p>
</li>
</ul>
</li>
</ul></body>
</html>
